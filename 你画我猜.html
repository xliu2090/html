<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
  <title>ä½ ç”»æˆ‘çŒœ Â· æ‰‹è´¦ç»˜æœ¬é£ï¼ˆå•æ–‡ä»¶ï¼‰</title>
  <style>
    :root{
      --paper:#fbf6ea;
      --paper2:#f4e9d8;
      --ink:#3a2f2a;
      --muted:#6b5f59;
      --accent:#d58e7b;
      --accent2:#87a88c;
      --danger:#b85a5a;
      --card:rgba(255,255,255,.70);
      --shadow: 0 10px 30px rgba(58,47,42,.12);
      --radius: 22px;
      --radius2: 16px;
      --safeTop: env(safe-area-inset-top);
      --safeBottom: env(safe-area-inset-bottom);
    }

    html,body{
      height:100%;
      margin:0;
      color:var(--ink);
      font-family: ui-rounded, system-ui, -apple-system, "PingFang SC", "Microsoft YaHei", "Noto Sans CJK SC", sans-serif;
      background:
        radial-gradient(1200px 900px at 20% 0%, #fff7e8 0%, transparent 60%),
        radial-gradient(1200px 900px at 80% 10%, #fbe7e0 0%, transparent 62%),
        linear-gradient(180deg, var(--paper) 0%, var(--paper2) 100%);
      overflow:hidden;
    }
    body::before{
      content:"";
      position:fixed; inset:0;
      pointer-events:none;
      opacity:.18;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='140' height='140'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.8' numOctaves='3' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='140' height='140' filter='url(%23n)' opacity='.55'/%3E%3C/svg%3E");
      mix-blend-mode:multiply;
    }

    .app{
      height:100dvh;
      display:flex;
      flex-direction:column;
      padding: calc(12px + var(--safeTop)) 12px calc(12px + var(--safeBottom));
      gap:10px;
      box-sizing:border-box;
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:10px 10px;
      border-radius: var(--radius);
      background: rgba(255,255,255,.45);
      box-shadow: var(--shadow);
      position:relative;
      overflow:hidden;
    }
    .topbar::before{
      content:"";
      position:absolute;
      width:88px; height:32px;
      left:12px; top:-10px;
      background: linear-gradient(135deg, rgba(242,214,166,.95), rgba(240,199,182,.85));
      border-radius:12px;
      transform: rotate(-7deg);
      box-shadow: 0 8px 18px rgba(58,47,42,.10);
    }
    .brand{
      position:relative;
      display:flex; flex-direction:column;
      gap:2px;
      padding-left:6px;
    }
    .brand .t{ font-weight:850; letter-spacing:.2px; font-size:15px; }
    .brand .s{ font-size:12px; color:var(--muted); }
    .chips{
      display:flex; flex-wrap:wrap;
      gap:6px;
      align-items:center;
      justify-content:flex-end;
    }
    .chip{
      font-size:12px;
      padding:6px 10px;
      border-radius:999px;
      background: rgba(255,255,255,.62);
      border: 1px dashed rgba(58,47,42,.18);
      color: var(--muted);
      user-select:none;
      white-space:nowrap;
    }
    .chip strong{ color:var(--ink); }

    main{ flex:1; min-height:0; position:relative; }
    .screen{
      position:absolute; inset:0;
      display:none;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
      padding: 6px 2px 2px;
    }
    .screen.active{ display:block; }

    .card{
      background: var(--card);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      border: 1px solid rgba(58,47,42,.10);
      padding: 14px;
      position:relative;
      overflow:hidden;
      backdrop-filter: blur(6px);
    }
    .card .tape{
      position:absolute;
      width:120px; height:34px;
      top:-10px;
      right:10px;
      background: linear-gradient(135deg, rgba(242,214,166,.95), rgba(240,199,182,.85));
      border-radius:12px;
      transform: rotate(8deg);
      box-shadow: 0 8px 18px rgba(58,47,42,.10);
      opacity:.9;
    }
    .card h2, .card h3{ margin:0 0 8px; font-size:16px; }
    .card p{
      margin: 6px 0;
      color: var(--muted);
      line-height:1.55;
      font-size:13px;
    }

    .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .col{ display:flex; flex-direction:column; gap:8px; }
    .btn{
      appearance:none;
      border:none;
      border-radius: 999px;
      padding: 12px 14px;
      font-weight:750;
      background: rgba(213,142,123,.20);
      color: var(--ink);
      box-shadow: 0 8px 18px rgba(58,47,42,.10);
      border: 1px solid rgba(213,142,123,.25);
      user-select:none;
      -webkit-tap-highlight-color: transparent;
      cursor:pointer;
      transition: transform .06s ease;
      display:inline-flex;
      align-items:center;
      gap:8px;
      justify-content:center;
    }
    .btn:active{ transform: scale(.98); }
    .btn.primary{
      background: rgba(135,168,140,.22);
      border-color: rgba(135,168,140,.30);
    }
    .btn.danger{
      background: rgba(184,90,90,.18);
      border-color: rgba(184,90,90,.26);
    }
    .btn.ghost{
      background: rgba(255,255,255,.55);
      border: 1px dashed rgba(58,47,42,.18);
      box-shadow:none;
      font-weight:650;
    }
    .btn.small{ padding: 9px 12px; font-size: 12px; font-weight:700; }
    .btn:disabled{ opacity:.55; cursor:not-allowed; }

    .input, select{
      width:100%;
      box-sizing:border-box;
      padding: 12px 12px;
      border-radius: 14px;
      border: 1px solid rgba(58,47,42,.18);
      background: rgba(255,255,255,.62);
      color: var(--ink);
      outline:none;
      font-size: 13px;
    }
    label{ font-size:12px; color: var(--muted); }
    .divider{ height:1px; background: rgba(58,47,42,.10); margin: 10px 0; }
    .grid{ display:grid; grid-template-columns: 1fr; gap:10px; }

    .prompt{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
    }
    .sticker{
      background: rgba(255,255,255,.72);
      border-radius: 18px;
      padding: 10px 12px;
      border: 1px dashed rgba(58,47,42,.20);
      box-shadow: 0 10px 20px rgba(58,47,42,.08);
      position:relative;
      overflow:hidden;
      flex:1;
      min-width: 0;
    }
    .sticker::before{
      content:"";
      position:absolute;
      left:-18px; top:12px;
      width:44px; height:20px;
      background: rgba(242,214,166,.85);
      border-radius: 10px;
      transform: rotate(-12deg);
      opacity:.85;
    }
    .word{
      font-size:18px;
      font-weight:900;
      letter-spacing:.4px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .meta{
      margin-top:4px;
      font-size:12px;
      color: var(--muted);
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }
    .timer{
      min-width: 84px;
      text-align:center;
      padding: 10px 12px;
      border-radius: 18px;
      background: rgba(255,255,255,.62);
      border: 1px dashed rgba(58,47,42,.20);
      box-shadow: 0 10px 20px rgba(58,47,42,.08);
      display:flex;
      flex-direction:column;
      justify-content:center;
      align-items:center;
      gap:2px;
    }
    .timer .sec{ font-size:18px; font-weight:900; }
    .timer .lab{ font-size:11px; color: var(--muted); }
    .timer.low{
      border-color: rgba(184,90,90,.35);
      background: rgba(184,90,90,.10);
    }

    .canvasWrap{ padding: 12px; }
    .canvasFrame{
      position:relative;
      border-radius: 18px;
      overflow:hidden;
      border: 1px solid rgba(58,47,42,.18);
      background: linear-gradient(180deg, rgba(255,255,255,.75), rgba(255,255,255,.62));
      box-shadow: inset 0 0 0 1px rgba(255,255,255,.35);
      touch-action: none; /* ç”»å¸ƒå®¹å™¨ç¦ç”¨é»˜è®¤æ‰‹åŠ¿ */
    }

    canvas{
      display:block;
      width:100%;
      height:48vh;
      max-height: 520px;
      min-height: 320px;
      background:
        linear-gradient(transparent 0, transparent 32px, rgba(58,47,42,.06) 33px) repeat,
        radial-gradient(1000px 700px at 20% 0%, rgba(213,142,123,.09), transparent 70%),
        radial-gradient(1000px 700px at 80% 10%, rgba(135,168,140,.09), transparent 70%),
        rgba(255,255,255,.75);
      background-size: 100% 34px, auto, auto, auto;

      touch-action: none; /* âœ… å…³é”®ï¼šéƒ¨åˆ†æ‰‹æœºåªè®¤åŠ åœ¨ canvas ä¸Š */
    }
    .canvasFrame::after{
      content:"";
      position:absolute; inset:0;
      pointer-events:none;
      opacity:.20;
      background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='120' height='120'%3E%3Cfilter id='n'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='.75' numOctaves='2'/%3E%3C/filter%3E%3Crect width='120' height='120' filter='url(%23n)' opacity='.4'/%3E%3C/svg%3E");
      mix-blend-mode:multiply;
    }

    .tools{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      justify-content:space-between;
      padding-top: 10px;
    }
    .tools .left, .tools .right{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
    }
    .pill{
      display:flex;
      align-items:center;
      gap:10px;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(255,255,255,.62);
      border: 1px dashed rgba(58,47,42,.18);
      color: var(--muted);
      font-size:12px;
    }
    input[type="range"]{ width: 120px; }

    .bubble{
      border-radius: 18px;
      padding: 12px 12px;
      background: rgba(255,255,255,.70);
      border: 1px solid rgba(58,47,42,.12);
      box-shadow: 0 10px 20px rgba(58,47,42,.08);
      position:relative;
    }
    .bubble::before{
      content:"";
      position:absolute;
      left: 14px;
      top: -10px;
      width: 22px;
      height: 22px;
      background: rgba(255,255,255,.70);
      border-left: 1px solid rgba(58,47,42,.12);
      border-top: 1px solid rgba(58,47,42,.12);
      transform: rotate(45deg);
    }
    .bubble .line{
      font-size:13px;
      line-height:1.55;
      color: var(--muted);
      margin: 4px 0;
      word-break: break-word;
    }
    .bubble .guess{
      font-size:18px;
      font-weight:900;
      color: var(--ink);
      margin: 2px 0 6px;
    }
    .bubble .tag{
      display:inline-flex;
      align-items:center;
      gap:6px;
      font-size:12px;
      color: var(--muted);
      padding: 6px 10px;
      border-radius:999px;
      background: rgba(213,142,123,.14);
      border: 1px dashed rgba(213,142,123,.22);
      margin-right:6px;
      margin-top:6px;
    }

    details{
      margin-top:10px;
      background: rgba(255,255,255,.55);
      border: 1px dashed rgba(58,47,42,.18);
      border-radius: 14px;
      padding: 10px 12px;
    }
    details summary{
      cursor:pointer;
      font-weight:800;
      color: var(--muted);
      font-size:12px;
      user-select:none;
    }
    details pre{
      white-space: pre-wrap;
      word-break: break-word;
      margin: 10px 0 0;
      font-size:12px;
      color: var(--muted);
      line-height:1.55;
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
    }

    .roundList{
      display:flex;
      flex-direction:column;
      gap:8px;
      margin-top:10px;
    }
    .roundItem{
      background: rgba(255,255,255,.62);
      border: 1px dashed rgba(58,47,42,.18);
      border-radius: 16px;
      padding: 10px 12px;
      display:flex;
      justify-content:space-between;
      gap:10px;
      align-items:flex-start;
    }
    .roundItem .w{ font-weight:900; }
    .roundItem .m{ font-size:12px; color: var(--muted); margin-top:2px; }
    .roundItem .p{ font-weight:900; white-space:nowrap; }

    .note{
      font-size:12px;
      color: var(--muted);
      line-height:1.55;
      background: rgba(255,255,255,.52);
      border: 1px dashed rgba(58,47,42,.14);
      border-radius: 16px;
      padding: 10px 12px;
    }
    .footerPad{ height: 8px; }
  </style>
</head>

<body>
  <div class="app" id="app">
    <div class="topbar">
      <div class="brand">
        <div class="t">ğŸ“’ ä½ ç”»æˆ‘çŒœ Â· æ‰‹è´¦ç»˜æœ¬é£</div>
        <div class="s">ç©å®¶ç”»ç”»ï¼ŒAI æ¥çŒœï¼ˆç§»åŠ¨ç«¯è§¦æ‘¸å‹å¥½ï¼‰</div>
      </div>
      <div class="chips">
        <div class="chip" id="chipRound"><strong>å›åˆ</strong> 0/0</div>
        <div class="chip" id="chipScore"><strong>ç§¯åˆ†</strong> 0</div>
        <div class="chip" id="chipStreak"><strong>è¿èƒœ</strong> 0</div>
      </div>
    </div>

    <main>
      <!-- ====== å¼€å§‹ç•Œé¢ ====== -->
      <section class="screen active" id="screenStart">
        <div class="card">
          <div class="tape"></div>
          <h2>ğŸŒ¿ ç©æ³•å°çº¸æ¡</h2>
          <p>ç³»ç»Ÿä¼šç»™ä½ ä¸€ä¸ªé¢˜ç›®ï¼Œä½ åœ¨ç”»å¸ƒä¸Šç”¨â€œé“…ç¬”â€ç”»å‡ºæ¥ï¼Œç„¶åç‚¹ <b>â€œè®© AI çŒœï¼â€</b>ã€‚</p>
          <p>çŒœå¯¹ï¼šåŠ åˆ† + è¿èƒœåŠ æˆï¼›çŒœé”™ï¼šç»§ç»­è¡¥å……ç»†èŠ‚å†è®© AI çŒœã€‚è¿˜æœ‰ï¼šå€’è®¡æ—¶æŒ‘æˆ˜ã€æç¤ºè´´çº¸ã€AI çš„æç¬‘è¯¯åˆ¤ã€‚</p>
          <div class="divider"></div>

          <div class="col">
            <div>
              <label>VectorEngine API Keyï¼ˆæœ¬åœ°ä¿å­˜ï¼Œä¸å†™æ­»åœ¨ä»£ç é‡Œï¼‰</label>
              <input class="input" id="apiKey" type="password" inputmode="text" placeholder="ç²˜è´´ä½ çš„ API Keyï¼ˆå»ºè®®ç”¨ä»£ç†é¿å…æš´éœ²ï¼‰" />
              <p style="margin-top:6px;font-size:12px;color:var(--muted);">
                âš ï¸ å®¢æˆ·ç«¯ç›´è¿ä¼šæš´éœ² Keyã€‚æ­£å¼ç¯å¢ƒå»ºè®®ï¼šä½ è‡ªå·±åŠ ä¸€å±‚åç«¯ä»£ç†ï¼Œå†ç”±æœ¬é¡µé¢è¯·æ±‚ä½ çš„ä»£ç†ã€‚
              </p>
            </div>

            <div class="row">
              <div style="flex:1; min-width: 140px;">
                <label>å›åˆæ•°</label>
                <select id="roundCount">
                  <option value="3">3 å›åˆï¼ˆè½»æ¾ï¼‰</option>
                  <option value="5" selected>5 å›åˆï¼ˆæ ‡å‡†ï¼‰</option>
                  <option value="7">7 å›åˆï¼ˆè€åŠ›ï¼‰</option>
                </select>
              </div>
              <div style="flex:1; min-width: 140px;">
                <label>å•å›åˆæ—¶é™</label>
                <select id="timeLimit">
                  <option value="45">45 ç§’ï¼ˆç´§å¼ ï¼‰</option>
                  <option value="60" selected>60 ç§’ï¼ˆèˆ’é€‚ï¼‰</option>
                  <option value="90">90 ç§’ï¼ˆæ‚ é—²ï¼‰</option>
                </select>
              </div>
            </div>

            <div class="row" style="justify-content:space-between;">
              <button class="btn ghost" id="btnToggleSound">ğŸ”Š éŸ³æ•ˆï¼šå¼€</button>
              <button class="btn ghost" id="btnClearSavedKey">ğŸ§¹ æ¸…é™¤å·²ä¿å­˜ Key</button>
            </div>

            <button class="btn primary" id="btnStartGame">ğŸ“– ç¿»å¼€æ—¥è®°ï¼Œå¼€å§‹ç”»ï¼</button>
          </div>
        </div>

        <div class="footerPad"></div>

        <div class="note">
          <b>å°æŠ€å·§ï¼š</b>ç”»â€œå¤§è½®å»“ + å…³é”®ç‰¹å¾â€æ›´å®¹æ˜“è¢«çŒœåˆ°ï¼Œæ¯”å¦‚ï¼šçŒ«=å°–è€³æœµ+èƒ¡é¡»+å°¾å·´ï¼›è‡ªè¡Œè½¦=ä¸¤ä¸ªåœ†+è½¦æ¶ã€‚<br/>
          <b>å¦‚æœ AI è°ƒç”¨å¤±è´¥ï¼š</b>å¯èƒ½æ˜¯ Key/æƒé™ã€æ¨¡å‹ä¸æ”¯æŒå›¾åƒã€æˆ–è¢« CORS æ‹¦æˆªï¼›ä½ ä»å¯ç”¨â€œè·³è¿‡/è‡ªåˆ¤â€å®Œæˆæµç¨‹ã€‚
        </div>
      </section>

      <!-- ====== æ¸¸æˆç•Œé¢ ====== -->
      <section class="screen" id="screenPlay">
        <div class="grid">
          <div class="card">
            <div class="prompt">
              <div class="sticker">
                <div class="word" id="promptWord">â€”</div>
                <div class="meta">
                  <span>ğŸ“Œ ç±»åˆ«ï¼š<b id="promptCategory">â€”</b></span>
                  <span>âœ¨ å·²ç”¨æç¤ºï¼š<b id="hintUsed">0</b></span>
                  <span>ğŸ æç¤ºè´´çº¸ï¼š<b id="hintCoins">2</b></span>
                </div>
              </div>
              <div class="timer" id="timerBox">
                <div class="sec" id="timerSec">60</div>
                <div class="lab">å€’è®¡æ—¶</div>
              </div>
            </div>
          </div>

          <div class="card canvasWrap">
            <div class="tape"></div>
            <h3>âœï¸ ç”»å¸ƒï¼ˆæ‰‹ç»˜æ—¥è®°çº¸ï¼‰</h3>

            <div class="canvasFrame" id="canvasFrame">
              <canvas id="drawCanvas"></canvas>
            </div>

            <div class="tools">
              <div class="left">
                <button class="btn small" id="btnPen">âœï¸ é“…ç¬”</button>
                <button class="btn small" id="btnEraser">ğŸ§½ æ©¡çš®</button>
                <div class="pill">
                  ç²—ç»†
                  <input type="range" id="brushSize" min="2" max="18" value="6" />
                  <span id="brushLabel">6</span>
                </div>
              </div>
              <div class="right">
                <button class="btn small ghost" id="btnUndo">â†©ï¸ æ’¤é”€</button>
                <button class="btn small danger" id="btnClear">ğŸ—‘ï¸ æ¸…ç©º</button>
              </div>
            </div>
          </div>

          <div class="card">
            <div class="tape"></div>
            <h3>ğŸ¤– AI çŒœæµ‹åŒº</h3>

            <div class="row">
              <button class="btn primary" id="btnGuess">ğŸš€ è®© AI çŒœï¼</button>
              <button class="btn" id="btnHint">ğŸ·ï¸ ç”¨æç¤ºè´´çº¸</button>
              <button class="btn ghost" id="btnSkip">â­ï¸ è·³è¿‡/è‡ªåˆ¤</button>
            </div>

            <div class="divider"></div>

            <div class="bubble" id="aiBubble">
              <div class="guess" id="aiGuess">ï¼ˆè¿˜æ²¡å¼€å§‹çŒœï¼‰</div>
              <div class="line" id="aiSub">ç”»å¾—è¶Šæ¸…æ™°ï¼ŒAI è¶Šå®¹æ˜“çŒœåˆ°ã€‚å¯ä»¥å¤šæ¬¡è®©å®ƒçŒœï¼</div>
              <div>
                <span class="tag" id="aiConfidenceTag">ğŸ¯ ç½®ä¿¡åº¦ï¼šâ€”</span>
                <span class="tag" id="aiFunnyTag">ğŸ§  æç¬‘è¯¯åˆ¤ï¼šâ€”</span>
              </div>

              <details id="aiThinkingBox">
                <summary>AI thinkingï¼ˆé»˜è®¤æŠ˜å ï¼Œç‚¹æˆ‘å±•å¼€ï¼‰</summary>
                <pre id="aiThinking">(æ— )</pre>
              </details>
            </div>

            <div class="divider"></div>

            <div class="note">
              <b>è¶£å‘³æœºåˆ¶ï¼š</b><br/>
              â€¢ è¿ç»­çŒœå¯¹ä¼šå åŠ åŠ åˆ†ï¼ˆè¿èƒœè¶Šé«˜ï¼Œè¶Šâ€œèµšâ€ï¼‰<br/>
              â€¢ æ¯å›åˆé»˜è®¤ 2 å¼ æç¤ºè´´çº¸ï¼Œç”¨å®Œå°±é ä½ äº†<br/>
              â€¢ çŒœé”™åˆ«æ€•ï¼šç»§ç»­è¡¥ç»†èŠ‚ â†’ å†è®© AI çŒœï¼ˆAI è¿˜ä¼šå˜´è´«è¯¯åˆ¤ï¼‰
            </div>

            <div class="row" style="margin-top:10px; justify-content:flex-end;">
              <button class="btn" id="btnNextRound" disabled>â¡ï¸ ä¸‹ä¸€é¢˜</button>
            </div>
          </div>
        </div>
      </section>

      <!-- ====== ç»“ç®—ç•Œé¢ ====== -->
      <section class="screen" id="screenEnd">
        <div class="card">
          <div class="tape"></div>
          <h2>ğŸ‰ æœ¬æ¬¡æ—¥è®°æ€»ç»“</h2>
          <p id="endSummary">â€”</p>

          <div class="row" style="justify-content:space-between;">
            <div class="chip"><strong>æœ¬å±€æ€»åˆ†</strong> <span id="endScore">0</span></div>
            <div class="chip"><strong>æœ€é«˜è¿èƒœ</strong> <span id="endBestStreak">0</span></div>
            <div class="chip"><strong>å†å²æœ€é«˜</strong> <span id="endHighScore">0</span></div>
          </div>

          <div class="divider"></div>

          <h3>ğŸ“Œ å›åˆè®°å½•</h3>
          <div class="roundList" id="roundList"></div>

          <div class="divider"></div>

          <div class="row">
            <button class="btn primary" id="btnRestart">ğŸ” å†ç¿»ä¸€é¡µï¼ˆé‡å¼€ï¼‰</button>
            <button class="btn ghost" id="btnBackToStart">ğŸ  å›åˆ°å°é¢</button>
          </div>
        </div>
      </section>
    </main>
  </div>

  <script>
    /******************************************************************
     * ä½ ç”»æˆ‘çŒœ Â· å•æ–‡ä»¶ç‰ˆï¼ˆä¿®å¤ç‰ˆï¼‰
     * âœ… ä¿®å¤â€œç”»å¸ƒæ²¡ååº”â€ï¼šæ¸¸æˆé¡µ display:none æ—¶åˆå§‹åŒ–å¯¼è‡´ canvas 0x0
     *    -> åˆ‡åˆ°æ¸¸æˆé¡µå requestAnimationFrame å† resize/init
     * âœ… canvas touch-action:none + PointerEvent + touch å…œåº•
     * å…¶ä½™ï¼š
     * - å¤šè½®ã€ç§¯åˆ†ã€è¿èƒœã€é™æ—¶ã€æç¤ºè´´çº¸ã€æ’¤é”€/æ¸…ç©º
     * - AI è°ƒç”¨ï¼šVectorEngine /v1/chat/completionsï¼ˆOpenAI å…¼å®¹ï¼‰
     * - AI thinking é»˜è®¤æŠ˜å ï¼ˆdetailsï¼‰
     * - Web Audio API éŸ³æ•ˆï¼ˆè½ç¬”/å€’è®¡æ—¶/çŒœæµ‹ä¸­/çŒœå¯¹/çŒœé”™ï¼‰
     ******************************************************************/

    // ========= é…ç½® =========
    const API_URL = "https://api.vectorengine.ai/v1/chat/completions";
    const MODEL = "claude-opus-4-5-20251101-thinking";

    // é¢˜åº“ï¼ˆå¯æ‰©å……ï¼‰
    const WORD_BANK = [
      { word:"çŒ«", category:"åŠ¨ç‰©", hints:["å°–è€³æœµ", "èƒ¡é¡»", "å°¾å·´"] , answers:["çŒ«","å°çŒ«","çŒ«å’ª"]},
      { word:"å¤ªé˜³", category:"è‡ªç„¶", hints:["åœ†", "å…‰èŠ’", "å¤©ç©ºé‡Œ"] , answers:["å¤ªé˜³","æ—¥"]},
      { word:"é›¨ä¼", category:"æ—¥å¸¸", hints:["å¼§å½¢", "æ‰‹æŸ„", "ä¸‹é›¨ç”¨"] , answers:["é›¨ä¼","ä¼"]},
      { word:"è‡ªè¡Œè½¦", category:"äº¤é€š", hints:["ä¸¤ä¸ªè½®å­", "è½¦æ¶", "è„šè¸"] , answers:["è‡ªè¡Œè½¦","å•è½¦","è„šè¸è½¦"]},
      { word:"è›‹ç³•", category:"é£Ÿç‰©", hints:["åˆ†å±‚", "èœ¡çƒ›", "å¥¶æ²¹"] , answers:["è›‹ç³•"]},
      { word:"çœ¼é•œ", category:"ç‰©å“", hints:["ä¸¤ä¸ªåœ†/æ–¹æ¡†", "é•œè…¿", "æˆ´åœ¨è„¸ä¸Š"] , answers:["çœ¼é•œ"]},
      { word:"æˆ¿å­", category:"å»ºç­‘", hints:["å±‹é¡¶", "çª—æˆ·", "é—¨"] , answers:["æˆ¿å­","æˆ¿å±‹","å°å±‹"]},
      { word:"é²¸é±¼", category:"åŠ¨ç‰©", hints:["å·¨å¤§", "å–·æ°´", "æµ·é‡Œ"] , answers:["é²¸é±¼","é²¸"]},
      { word:"ç«ç®­", category:"ç§‘æŠ€", hints:["å°–å¤´", "å°¾ç„°", "é£å‘å¤ªç©º"] , answers:["ç«ç®­"]},
      { word:"å†°æ·‡æ·‹", category:"é£Ÿç‰©", hints:["è›‹ç­’", "çƒå½¢", "èåŒ–"] , answers:["å†°æ·‡æ·‹","å†°æ¿€å‡Œ"]},
      { word:"æ ‘", category:"è‡ªç„¶", hints:["æ ‘å¹²", "æ ‘å† ", "å¶å­"] , answers:["æ ‘","å¤§æ ‘"]},
      { word:"æ±‰å ¡", category:"é£Ÿç‰©", hints:["ä¸Šä¸‹ä¸¤ç‰‡é¢åŒ…", "è‚‰é¥¼", "ç”Ÿèœ"] , answers:["æ±‰å ¡","æ±‰å ¡åŒ…"]},
      { word:"æ‰‹æœº", category:"æ—¥å¸¸", hints:["é•¿æ–¹å½¢", "å±å¹•", "æ‘„åƒå¤´"] , answers:["æ‰‹æœº","æ™ºèƒ½æ‰‹æœº"]},
      { word:"é±¼", category:"åŠ¨ç‰©", hints:["é±¼é³", "å°¾å·´", "æ°´é‡Œ"] , answers:["é±¼","å°é±¼"]},
    ];

    const FUNNY_WRONG = [
      "ä¸€åªå¾ˆæœ‰ç†æƒ³çš„åœŸè±†",
      "æ­£åœ¨å¼€ä¼šçš„å¯¿å¸",
      "æˆ´å¸½å­çš„äº‘æœµ",
      "è¿·è·¯çš„ç‰™åˆ·",
      "ä¼šå”±æ­Œçš„æ‰³æ‰‹",
      "ä¸€é¢—æƒ³å½“æ˜æ˜Ÿçš„ç•ªèŒ„",
      "æ­£åœ¨å¥èº«çš„å›¢å­",
      "æ¥è‡ªå¤–æ˜Ÿçš„æ‹–é‹"
    ];

    const $ = (s)=>document.querySelector(s);

    // ========= UI =========
    const screenStart = $("#screenStart");
    const screenPlay  = $("#screenPlay");
    const screenEnd   = $("#screenEnd");

    const chipRound = $("#chipRound");
    const chipScore = $("#chipScore");
    const chipStreak= $("#chipStreak");

    const apiKeyInput = $("#apiKey");
    const roundCountSel = $("#roundCount");
    const timeLimitSel  = $("#timeLimit");

    const btnStartGame = $("#btnStartGame");
    const btnToggleSound = $("#btnToggleSound");
    const btnClearSavedKey = $("#btnClearSavedKey");

    const promptWord = $("#promptWord");
    const promptCategory = $("#promptCategory");
    const hintUsedEl = $("#hintUsed");
    const hintCoinsEl= $("#hintCoins");

    const timerBox = $("#timerBox");
    const timerSec = $("#timerSec");

    const canvas = $("#drawCanvas");
    const canvasFrame = $("#canvasFrame");
    const ctx = canvas.getContext("2d", { willReadFrequently: true });

    const btnPen = $("#btnPen");
    const btnEraser = $("#btnEraser");
    const btnUndo = $("#btnUndo");
    const btnClear = $("#btnClear");
    const brushSize = $("#brushSize");
    const brushLabel= $("#brushLabel");

    const btnGuess = $("#btnGuess");
    const btnHint = $("#btnHint");
    const btnSkip = $("#btnSkip");
    const btnNextRound = $("#btnNextRound");

    const aiGuessEl = $("#aiGuess");
    const aiSubEl   = $("#aiSub");
    const aiConfidenceTag = $("#aiConfidenceTag");
    const aiFunnyTag = $("#aiFunnyTag");
    const aiThinkingBox = $("#aiThinkingBox");
    const aiThinkingPre = $("#aiThinking");

    const endSummary = $("#endSummary");
    const endScore = $("#endScore");
    const endBestStreak = $("#endBestStreak");
    const endHighScore = $("#endHighScore");
    const roundList = $("#roundList");
    const btnRestart = $("#btnRestart");
    const btnBackToStart = $("#btnBackToStart");

    // ========= éŸ³æ•ˆï¼ˆWeb Audioï¼‰ =========
    const SFX = (() => {
      let enabled = true;
      let ac = null;
      let master = null;
      let tickingInterval = null;

      function ensure(){
        if(!enabled) return null;
        if(ac) return ac;
        ac = new (window.AudioContext || window.webkitAudioContext)();
        master = ac.createGain();
        master.gain.value = 0.55;
        master.connect(ac.destination);
        return ac;
      }

      function resume(){
        const a = ensure();
        if(a && a.state === "suspended") a.resume().catch(()=>{});
      }

      function beep(freq=440, dur=0.08, type="sine", gain=0.12){
        const a = ensure(); if(!a) return;
        const o = a.createOscillator();
        const g = a.createGain();
        o.type = type;
        o.frequency.value = freq;
        g.gain.value = gain;
        o.connect(g);
        g.connect(master);
        const t = a.currentTime;
        g.gain.setValueAtTime(0.0001, t);
        g.gain.exponentialRampToValueAtTime(gain, t+0.01);
        g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
        o.start(t);
        o.stop(t+dur+0.02);
      }

      function noiseBurst(dur=0.06, gain=0.08, hp=800){
        const a = ensure(); if(!a) return;
        const bufferSize = Math.floor(a.sampleRate * dur);
        const buffer = a.createBuffer(1, bufferSize, a.sampleRate);
        const data = buffer.getChannelData(0);
        for(let i=0;i<bufferSize;i++){
          data[i] = (Math.random()*2-1) * Math.pow(1 - i/bufferSize, 2);
        }
        const src = a.createBufferSource();
        src.buffer = buffer;

        const filter = a.createBiquadFilter();
        filter.type = "highpass";
        filter.frequency.value = hp;

        const g = a.createGain();
        g.gain.value = gain;

        src.connect(filter);
        filter.connect(g);
        g.connect(master);

        src.start();
        src.stop(a.currentTime + dur);
      }

      function scribble(){
        noiseBurst(0.04, 0.06, 900);
      }

      function start(){
        resume();
        beep(523,0.07,"triangle",0.12);
        beep(659,0.08,"triangle",0.10);
      }
      function correct(){
        beep(784,0.08,"sine",0.12);
        beep(988,0.10,"sine",0.12);
        beep(1319,0.12,"triangle",0.14);
      }
      function wrong(){
        beep(220,0.12,"sawtooth",0.08);
        beep(196,0.14,"sawtooth",0.07);
      }
      function thinkingTick(){
        noiseBurst(0.08, 0.04, 1200);
        beep(392,0.03,"sine",0.03);
      }

      function startTicking(){
        if(!enabled) return;
        stopTicking();
        tickingInterval = setInterval(()=>beep(880,0.02,"sine",0.02), 1000);
      }
      function stopTicking(){
        if(tickingInterval){ clearInterval(tickingInterval); tickingInterval=null; }
      }

      function setEnabled(v){
        enabled = v;
        if(!enabled) stopTicking();
      }
      function isEnabled(){ return enabled; }

      return { resume, scribble, start, correct, wrong, thinkingTick, startTicking, stopTicking, setEnabled, isEnabled };
    })();

    // ========= çŠ¶æ€ =========
    const state = {
      phase: "start",
      roundsTotal: 5,
      timeLimit: 60,
      roundIndex: 0,
      score: 0,
      streak: 0,
      bestStreak: 0,
      hintCoins: 2,

      current: null,
      timerLeft: 60,
      timerId: null,
      guessCount: 0,
      hintUsed: 0,
      roundLog: [],
    };

    // ========= ç”»ç¬” =========
    const draw = {
      mode: "pen",
      size: 6,
      isDown: false,
      last: null,
      undoStack: [],
      maxUndo: 20,
      lastScribbleAt: 0,
      dpr: 1,
    };

    // ========= æœ¬åœ°å­˜å‚¨é”® =========
    const LS = {
      key: "pict_ai_key",
      sound: "pict_sound",
      high: "pict_highscore"
    };

    function setScreen(which){
      state.phase = which;
      screenStart.classList.toggle("active", which==="start");
      screenPlay.classList.toggle("active", which==="play");
      screenEnd.classList.toggle("active", which==="end");

      // âœ… å…³é”®ä¿®å¤ï¼šåˆ‡åˆ° play æ—¶ï¼Œç­‰å¸ƒå±€ç”Ÿæ•ˆåå† resize canvas
      if(which === "play"){
        requestAnimationFrame(()=>{
          ensureCanvasReady(true);
        });
      }
    }

    function normalizeText(s){
      return (s||"")
        .toString()
        .trim()
        .toLowerCase()
        .replace(/\s+/g,"")
        .replace(/[ï¼Œã€‚ï¼ï¼Ÿ,.!?;:Â·ã€"'â€œâ€â€˜â€™ï¼ˆï¼‰()ã€ã€‘\[\]{}<>]/g,"");
    }

    function updateTopChips(){
      chipRound.innerHTML = `<strong>å›åˆ</strong> ${Math.min(state.roundIndex+1,state.roundsTotal)}/${state.roundsTotal}`;
      chipScore.innerHTML = `<strong>ç§¯åˆ†</strong> ${state.score}`;
      chipStreak.innerHTML= `<strong>è¿èƒœ</strong> ${state.streak}`;
    }

    function shuffle(arr){
      const a = arr.slice();
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i],a[j]]=[a[j],a[i]];
      }
      return a;
    }

    function pickRounds(n){
      return shuffle(WORD_BANK).slice(0, Math.min(n, WORD_BANK.length));
    }

    // ========= Canvas å°ºå¯¸ï¼ˆæ ¸å¿ƒï¼šå¿…é¡»åœ¨å¯è§åç®— rectï¼‰ =========
    function resizeCanvasKeepContent(){
      const rect = canvasFrame.getBoundingClientRect();

      // å¦‚æœå±å¹•è¿˜ä¸å¯è§/å¸ƒå±€æœªè®¡ç®—ï¼ˆwidth=0ï¼‰ï¼Œç›´æ¥è·³è¿‡
      if(rect.width < 10){
        return false;
      }

      // ä¿å­˜å½“å‰å†…å®¹
      const dataUrl = canvas.toDataURL("image/png");

      const dpr = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
      draw.dpr = dpr;

      // è®©å†…éƒ¨åƒç´ æŒ‰ DPR æ”¾å¤§ï¼Œç»˜å›¾ç”¨ CSS åƒç´ åæ ‡ï¼ˆctx scaleï¼‰
      const cssW = rect.width;
      // canvasFrame çš„é«˜åº¦ç”± canvas CSS height å†³å®šï¼Œå– rect.height æ›´å‡†ç¡®
      const cssH = Math.min(rect.height || (window.innerHeight * 0.52), window.innerHeight * 0.62);

      canvas.width  = Math.max(2, Math.floor(cssW * dpr));
      canvas.height = Math.max(2, Math.floor(cssH * dpr));
      canvas.style.width = cssW + "px";
      canvas.style.height = cssH + "px";

      ctx.setTransform(1,0,0,1,0,0);
      ctx.scale(dpr, dpr);

      // æ¢å¤å†…å®¹
      const img = new Image();
      img.onload = () => {
        ctx.save();
        // ç”»åˆ°å†…éƒ¨åƒç´ ç©ºé—´ï¼ˆåŸå›¾æ˜¯å†…éƒ¨åƒç´ æˆªå›¾ï¼‰
        ctx.setTransform(1,0,0,1,0,0);
        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
        ctx.restore();
      };
      img.src = dataUrl;

      return true;
    }

    // âœ… ä¿®å¤ç‚¹ï¼šç¡®ä¿ canvas ä¸æ˜¯ 0x0ï¼ˆåˆ‡å±åä¸€å®šè¦è°ƒç”¨ï¼‰
    function ensureCanvasReady(force=false){
      const need = force || canvas.width < 10 || canvas.height < 10;
      if(!need) return;

      // è¿ç»­ä¸¤å¸§æ›´ç¨³ï¼ˆæŸäº›æ‰‹æœºç¬¬ä¸€æ¬¡ RAF rect è¿˜æ²¡åˆ·æ–°ï¼‰
      requestAnimationFrame(()=>{
        const ok1 = resizeCanvasKeepContent();
        if(!ok1){
          requestAnimationFrame(()=>resizeCanvasKeepContent());
        }
      });
    }

    function clearCanvas(silent=false){
      ctx.save();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.restore();
      draw.undoStack = [];
      if(!silent) SFX.wrong();
    }

    function pushUndo(){
      try{
        if(draw.undoStack.length >= draw.maxUndo) draw.undoStack.shift();
        const snap = ctx.getImageData(0,0,canvas.width,canvas.height);
        draw.undoStack.push(snap);
      }catch(e){}
    }

    function undo(){
      const snap = draw.undoStack.pop();
      if(!snap) return;
      ctx.putImageData(snap, 0, 0);
    }

    function isCanvasBlankFast(){
      const w = canvas.width, h = canvas.height;
      if(!w || !h) return true;
      const sample = 18;
      const stepX = Math.max(1, Math.floor(w / sample));
      const stepY = Math.max(1, Math.floor(h / sample));
      const img = ctx.getImageData(0,0,w,h).data;
      for(let y=0;y<h;y+=stepY){
        for(let x=0;x<w;x+=stepX){
          const i = (y*w + x)*4;
          if(img[i+3] > 8) return false;
        }
      }
      return true;
    }

    function getLocalPointLike(clientX, clientY){
      const rect = canvas.getBoundingClientRect();
      return { x: (clientX - rect.left), y: (clientY - rect.top) };
    }

    function drawSegment(a,b){
      const size = draw.size;
      const isEraser = draw.mode === "eraser";

      ctx.save();
      ctx.lineCap = "round";
      ctx.lineJoin = "round";
      ctx.lineWidth = isEraser ? size*2.2 : size;

      if(isEraser){
        ctx.globalCompositeOperation = "destination-out";
        ctx.strokeStyle = "rgba(0,0,0,1)";
        ctx.globalAlpha = 1;
      }else{
        ctx.globalCompositeOperation = "source-over";
        ctx.strokeStyle = "rgba(59,47,43,.86)";
        ctx.globalAlpha = 0.85;
      }

      ctx.beginPath();
      ctx.moveTo(a.x, a.y);
      ctx.lineTo(b.x, b.y);
      ctx.stroke();

      if(!isEraser){
        const dx = b.x - a.x, dy = b.y - a.y;
        const dist = Math.hypot(dx,dy);
        const steps = Math.max(2, Math.floor(dist / 6));
        for(let i=0;i<steps;i++){
          const t = i/steps;
          const px = a.x + dx*t + (Math.random()*2-1)*0.9;
          const py = a.y + dy*t + (Math.random()*2-1)*0.9;
          ctx.globalAlpha = 0.14;
          ctx.beginPath();
          ctx.arc(px, py, Math.random()*0.9 + 0.2, 0, Math.PI*2);
          ctx.fillStyle = "rgba(59,47,43,.55)";
          ctx.fill();
        }
      }
      ctx.restore();
    }

    // ========= æ¸¸æˆæµç¨‹ =========
    let selectedRounds = [];

    function startGame(){
      state.roundsTotal = parseInt(roundCountSel.value, 10);
      state.timeLimit = parseInt(timeLimitSel.value, 10);

      state.roundIndex = 0;
      state.score = 0;
      state.streak = 0;
      state.bestStreak = 0;
      state.hintCoins = 2;
      state.roundLog = [];

      selectedRounds = pickRounds(state.roundsTotal);

      updateTopChips();
      setScreen("play");
      SFX.start();

      // âœ… å…³é”®ä¿®å¤ï¼šç­‰æ¸¸æˆé¡µæ˜¾ç¤ºå‡ºæ¥åå† loadRoundï¼ˆå¦åˆ™ canvas å¯èƒ½è¿˜æ˜¯ 0x0ï¼‰
      requestAnimationFrame(()=>{
        ensureCanvasReady(true);
        loadRound(0);
      });
    }

    function loadRound(i){
      ensureCanvasReady(); // åŒä¿é™©
      state.roundIndex = i;
      state.current = selectedRounds[i];
      state.timerLeft = state.timeLimit;
      state.guessCount = 0;
      state.hintUsed = 0;
      state.hintCoins = 2;

      promptWord.textContent = state.current.word;
      promptCategory.textContent = state.current.category;
      hintUsedEl.textContent = state.hintUsed;
      hintCoinsEl.textContent = state.hintCoins;

      timerSec.textContent = state.timerLeft;
      timerBox.classList.remove("low");

      aiGuessEl.textContent = "ï¼ˆè¿˜æ²¡å¼€å§‹çŒœï¼‰";
      aiSubEl.textContent = "ä½ å¯ä»¥å¤šç”»ç‚¹å…³é”®ç‰¹å¾ï¼Œå†è®© AI çŒœï½";
      aiConfidenceTag.textContent = "ğŸ¯ ç½®ä¿¡åº¦ï¼šâ€”";
      aiFunnyTag.textContent = "ğŸ§  æç¬‘è¯¯åˆ¤ï¼šâ€”";
      aiThinkingPre.textContent = "(æ— )";
      aiThinkingBox.open = false;

      btnNextRound.disabled = true;
      btnGuess.disabled = false;

      clearCanvas(true);
      pushUndo();

      updateTopChips();
      startTimer();
    }

    function startTimer(){
      stopTimer();
      SFX.stopTicking();
      state.timerId = setInterval(()=>{
        state.timerLeft -= 1;
        timerSec.textContent = state.timerLeft;

        if(state.timerLeft <= 10){
          timerBox.classList.add("low");
          if(state.timerLeft === 10) SFX.startTicking();
        }
        if(state.timerLeft <= 0){
          stopTimer();
          SFX.stopTicking();
          onTimeUp();
        }
      }, 1000);
    }

    function stopTimer(){
      if(state.timerId){
        clearInterval(state.timerId);
        state.timerId = null;
      }
    }

    function onTimeUp(){
      btnGuess.disabled = true;
      btnNextRound.disabled = false;

      state.streak = 0;
      updateTopChips();

      aiGuessEl.textContent = "â° æ—¶é—´åˆ°ï¼";
      aiSubEl.textContent = `è¿™é¢˜ç­”æ¡ˆæ˜¯ã€Œ${state.current.word}ã€ã€‚ä¸‹ä¸€é¢˜ç»§ç»­åŠ æ²¹ï½`;

      state.roundLog.push({
        word: state.current.word,
        ok: false,
        points: 0,
        guesses: state.guessCount,
        timeLeft: 0,
        note: "æ—¶é—´åˆ°"
      });
    }

    function endGame(){
      stopTimer();
      SFX.stopTicking();
      setScreen("end");

      const total = state.score;
      const high = Math.max(total, parseInt(localStorage.getItem(LS.high)||"0",10));
      localStorage.setItem(LS.high, String(high));

      endScore.textContent = total;
      endBestStreak.textContent = state.bestStreak;
      endHighScore.textContent = high;

      endSummary.textContent = `ä½ å®Œæˆäº† ${state.roundsTotal} å›åˆï¼Œæœ€é«˜è¿èƒœ ${state.bestStreak}ï¼Œæ€»åˆ† ${total} åˆ†ã€‚ä»Šå¤©çš„æ—¥è®°é¡µï¼šç”»å¾—å¾ˆæœ‰çµé­‚ï½`;

      roundList.innerHTML = "";
      state.roundLog.forEach((r, idx)=>{
        const el = document.createElement("div");
        el.className = "roundItem";
        el.innerHTML = `
          <div style="min-width:0;">
            <div class="w">ç¬¬ ${idx+1} å›åˆ Â· ${r.ok ? "âœ… çŒœå¯¹" : "âŒ æœªçŒœä¸­"} Â· ã€Œ${escapeHtml(r.word)}ã€</div>
            <div class="m">å°è¯• ${r.guesses} æ¬¡ Â· å‰©ä½™ ${r.timeLeft}s Â· ${escapeHtml(r.note||"")}</div>
          </div>
          <div class="p">${r.ok ? "+" : ""}${r.points}</div>
        `;
        roundList.appendChild(el);
      });
    }

    function nextRound(){
      const next = state.roundIndex + 1;
      if(next >= state.roundsTotal) endGame();
      else loadRound(next);
    }

    // ========= æç¤ºè´´çº¸ =========
    function useHint(){
      if(state.hintCoins <= 0){
        aiSubEl.textContent = "æç¤ºè´´çº¸ç”¨å®Œå•¦ï¼é ä½ çš„çµæ„Ÿç»§ç»­ç”»ï½";
        SFX.wrong();
        return;
      }
      state.hintCoins -= 1;
      state.hintUsed += 1;

      hintCoinsEl.textContent = state.hintCoins;
      hintUsedEl.textContent = state.hintUsed;

      const hint = state.current.hints[Math.min(state.hintUsed-1, state.current.hints.length-1)];
      aiSubEl.textContent = `ğŸ·ï¸ æç¤ºè´´çº¸ï¼š${hint}ï¼ˆç»§ç»­ç”»è¿™ä¸ªç‰¹å¾æ›´å¥½çŒœï¼‰`;
    }

    // ========= AI çŒœæµ‹ =========
    async function aiGuess(){
      SFX.resume();

      const apiKey = (apiKeyInput.value || "").trim() || (localStorage.getItem(LS.key)||"").trim();
      if(!apiKey){
        aiGuessEl.textContent = "âš ï¸ éœ€è¦ API Key";
        aiSubEl.textContent = "è¯·å›åˆ°å°é¢é¡µç²˜è´´ API Keyï¼ˆæˆ–å·²ä¿å­˜åé‡å¼€ï¼‰ã€‚";
        SFX.wrong();
        return;
      }

      if(isCanvasBlankFast()){
        aiGuessEl.textContent = "ï¼ˆç”»å¸ƒè¿˜æ˜¯ç©ºçš„ï¼‰";
        aiSubEl.textContent = "å…ˆç”»ä¸¤ç¬”å†è®© AI çŒœï½";
        SFX.wrong();
        return;
      }

      btnGuess.disabled = true;
      state.guessCount += 1;

      aiGuessEl.textContent = "ğŸ¤” AI æ­£åœ¨ç›¯ç€ä½ çš„æ¶‚é¸¦â€¦";
      aiSubEl.textContent = "ï¼ˆçŒœæµ‹ä¸­â€¦ï¼‰";
      aiConfidenceTag.textContent = "ğŸ¯ ç½®ä¿¡åº¦ï¼šâ€”";
      aiFunnyTag.textContent = "ğŸ§  æç¬‘è¯¯åˆ¤ï¼šâ€”";
      aiThinkingPre.textContent = "(ç­‰å¾…è¿”å›â€¦)";
      aiThinkingBox.open = false;

      const thinkPulse = setInterval(()=>SFX.thinkingTick(), 320);

      try{
        const dataUrl = getCanvasDataUrlDownscaled(768);

        const prompt = [
          "ä½ æ˜¯ä¸€ä¸ªâ€˜ä½ ç”»æˆ‘çŒœâ€™çš„AIè£åˆ¤ã€‚ä½ ä¼šæ”¶åˆ°ç©å®¶çš„æ¶‚é¸¦å›¾ç‰‡ã€‚",
          "è¯·æ ¹æ®å›¾ç‰‡çŒœæµ‹ç”»çš„æ˜¯ä»€ä¹ˆï¼ˆç”¨ä¸­æ–‡ã€å°½é‡ç®€çŸ­ï¼Œä¼˜å…ˆåè¯æˆ–çŸ­è¯­ï¼‰ã€‚",
          "è¯·ä¸¥æ ¼æŒ‰å¦‚ä¸‹æ ¼å¼è¾“å‡ºï¼ˆæ¯è¡Œä¸€é¡¹ï¼‰ï¼š",
          "GUESS: <ä½ çš„çŒœæµ‹>",
          "CONFIDENCE: <0åˆ°1çš„å°æ•°>",
          "FUNNY_MISGUESS: <ä¸€ä¸ªæç¬‘çš„é”™è¯¯çŒœæµ‹>",
          "THINKING: <ä½ çš„æ€è€ƒè¿‡ç¨‹ï¼Œå¯ç¨é•¿>",
          "",
          "æ³¨æ„ï¼šå¦‚æœä½ ä¸ç¡®å®šï¼Œä¹Ÿè¦ç»™å‡ºæœ€å¯èƒ½çš„ä¸€ä¸ªçŒœæµ‹ã€‚"
        ].join("\n");

        const payload = {
          model: MODEL,
          temperature: 0.4,
          max_tokens: 600,
          stream: false,
          messages: [
            { role: "system", content: "ä½ æ˜¯ä¸€ä¸ªæ¸©æŸ”ä½†å˜´è´«çš„æ‰‹è´¦è£åˆ¤ã€‚å›ç­”è¦å¯çˆ±ä¸€ç‚¹ï¼Œä½†çŒœæµ‹è¦è®¤çœŸã€‚" },
            {
              role: "user",
              content: [
                { type: "text", text: prompt },
                { type: "image_url", image_url: { url: dataUrl } }
              ]
            }
          ]
        };

        const res = await fetch(API_URL, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "Authorization": "Bearer " + apiKey
          },
          body: JSON.stringify(payload)
        });

        const text = await res.text();
        let json;
        try { json = JSON.parse(text); } catch(e){ json = null; }

        if(!res.ok){
          throw new Error(`HTTP ${res.status}: ${json?.error?.message || text.slice(0,220)}`);
        }
        if(!json?.choices?.[0]?.message?.content){
          throw new Error("è¿”å›æ ¼å¼å¼‚å¸¸ï¼šç¼ºå°‘ choices[0].message.content");
        }

        const raw = String(json.choices[0].message.content);
        const parsed = parseModelOutput(raw);

        aiGuessEl.textContent = parsed.guess || "ï¼ˆæ²¡çŒœå‡ºæ¥ï¼‰";
        aiConfidenceTag.textContent = `ğŸ¯ ç½®ä¿¡åº¦ï¼š${isFinite(parsed.confidence) ? parsed.confidence.toFixed(2) : "â€”"}`;
        aiFunnyTag.textContent = `ğŸ§  æç¬‘è¯¯åˆ¤ï¼š${parsed.funny || pick(FUNNY_WRONG)}`;
        aiSubEl.textContent = parsed.guess
          ? "æˆ‘å·²ç»ç»™å‡ºçŒœæµ‹å•¦ï¼šå¦‚æœçŒœé”™ï¼Œä½ å¯ä»¥ç»§ç»­åŠ ç»†èŠ‚å†è®©æˆ‘çŒœï½"
          : "æˆ‘æœ‰ç‚¹è¿·ç³Šâ€¦ä½ å¯ä»¥ç”»å¾—æ›´æ˜æ˜¾ä¸€ç‚¹ï¼ˆè½®å»“+å…³é”®ç‰¹å¾ï¼‰å†è¯•ä¸€æ¬¡ï½";

        aiThinkingPre.textContent = parsed.thinking || "(æ—  / æ¨¡å‹æœªè¿”å› thinking)";
        aiThinkingBox.open = false;

        const ok = isCorrectGuess(parsed.guess, state.current.answers);
        if(ok) onCorrect(parsed.guess, parsed.confidence);
        else onWrong(parsed.guess, parsed.funny);

      }catch(err){
        aiGuessEl.textContent = "âš ï¸ AI è°ƒç”¨å¤±è´¥";
        aiSubEl.textContent =
          "å¯èƒ½åŸå› ï¼šKey/æƒé™ä¸å¯¹ã€æ¨¡å‹ä¸æ”¯æŒå›¾åƒã€æˆ–æµè§ˆå™¨è¢« CORS æ‹¦æˆªã€‚\n" +
          "ä½ ä»å¯ç‚¹ã€Œè·³è¿‡/è‡ªåˆ¤ã€ç»§ç»­æµç¨‹ã€‚\n" +
          "é”™è¯¯ä¿¡æ¯ï¼š" + (err?.message || String(err));

        aiConfidenceTag.textContent = "ğŸ¯ ç½®ä¿¡åº¦ï¼šâ€”";
        aiFunnyTag.textContent = "ğŸ§  æç¬‘è¯¯åˆ¤ï¼šâ€”";
        aiThinkingPre.textContent = "(æ— )";
        aiThinkingBox.open = false;

        SFX.wrong();
        btnGuess.disabled = false;
      }finally{
        clearInterval(thinkPulse);
      }
    }

    function parseModelOutput(raw){
      const out = { guess:"", confidence: NaN, funny:"", thinking:"" };
      const text = raw.replace(/\r/g,"").trim();

      function pickLine(key){
        const re = new RegExp(`^\\s*${key}\\s*[:ï¼š]\\s*(.*)$`, "im");
        const m = text.match(re);
        return m ? m[1].trim() : "";
      }

      out.guess = pickLine("GUESS") || pickLine("ç­”æ¡ˆ") || "";
      const c = pickLine("CONFIDENCE") || pickLine("ç½®ä¿¡åº¦") || "";
      if(c){
        const num = parseFloat(c);
        if(isFinite(num)) out.confidence = Math.max(0, Math.min(1, num));
      }
      out.funny = pickLine("FUNNY_MISGUESS") || pickLine("æç¬‘è¯¯åˆ¤") || "";

      const m = text.match(/^\s*THINKING\s*[:ï¼š]\s*([\s\S]*)$/im);
      if(m) out.thinking = m[1].trim();

      if(!out.guess){
        const first = text.split("\n").find(l=>l.trim()) || "";
        out.guess = first.slice(0, 24);
      }
      return out;
    }

    function isCorrectGuess(guess, answers){
      const g = normalizeText(guess);
      if(!g) return false;
      return (answers||[]).some(a=>{
        const aa = normalizeText(a);
        return g === aa || g.includes(aa) || aa.includes(g);
      });
    }

    function onCorrect(guess, conf){
      stopTimer();
      SFX.stopTicking();

      const base = 100;
      const timeBonus = Math.max(0, state.timerLeft) * 2;
      const streakBonus = state.streak * 18;
      const triesPenalty = Math.max(0, state.guessCount - 1) * 12;
      const hintPenalty = state.hintUsed * 10;

      const gained = Math.max(10, base + timeBonus + streakBonus - triesPenalty - hintPenalty);

      state.score += gained;
      state.streak += 1;
      state.bestStreak = Math.max(state.bestStreak, state.streak);

      aiSubEl.textContent = `âœ… çŒœå¯¹å•¦ï¼ä½ ç”»çš„æ˜¯ã€Œ${state.current.word}ã€ã€‚æœ¬å›åˆ +${gained} åˆ†ï¼ˆè¿èƒœï¼š${state.streak}ï¼‰ã€‚`;
      aiConfidenceTag.textContent = `ğŸ¯ ç½®ä¿¡åº¦ï¼š${isFinite(conf) ? conf.toFixed(2) : "â€”"} Â· âœ… å‘½ä¸­`;
      aiFunnyTag.textContent = `ğŸ§  æç¬‘è¯¯åˆ¤ï¼šä»Šå¤©ä¸éœ€è¦å®ƒç™»åœºï½`;

      state.roundLog.push({
        word: state.current.word,
        ok: true,
        points: gained,
        guesses: state.guessCount,
        timeLeft: state.timerLeft,
        note: state.hintUsed ? `ç”¨äº† ${state.hintUsed} å¼ æç¤ºè´´çº¸` : "çº¯æ‰‹æ„Ÿé€šå…³"
      });

      updateTopChips();
      btnNextRound.disabled = false;
      btnGuess.disabled = true;

      SFX.correct();
    }

    function onWrong(guess, funny){
      state.streak = 0;
      updateTopChips();

      const roast = pick([
        "æˆ‘å¥½åƒè¢«ä½ çš„è‰ºæœ¯æ°”æ¯æ™ƒäº†ä¸€ä¸‹ã€‚",
        "è¿™çº¿æ¡â€¦æœ‰ç‚¹åƒâ€¦æˆ‘å…ˆä¸è¯´ã€‚",
        "æˆ‘çœ‹åˆ°äº†çµé­‚ï¼Œä½†è¿˜æ²¡çœ‹æ¸…ä¸»é¢˜ã€‚",
        "å†åŠ ç‚¹å…³é”®ç‰¹å¾ï¼Œæˆ‘å°±è¦å¼€æ‚Ÿäº†ï¼"
      ]);

      aiSubEl.textContent = `âŒ è¿™æ¬¡æ²¡çŒœä¸­ï¼šæˆ‘çŒœã€Œ${guess||"ï¼ˆç©ºï¼‰"}ã€ã€‚${roast} ç»§ç»­è¡¥ç»†èŠ‚å†è¯•ï½`;
      aiFunnyTag.textContent = `ğŸ§  æç¬‘è¯¯åˆ¤ï¼š${funny || pick(FUNNY_WRONG)}`;

      SFX.wrong();
      btnGuess.disabled = false;
    }

    function getCanvasDataUrlDownscaled(maxSide=768){
      const w = canvas.width, h = canvas.height;
      const scale = Math.min(1, maxSide / Math.max(w,h));
      const tw = Math.max(1, Math.floor(w * scale));
      const th = Math.max(1, Math.floor(h * scale));

      const off = document.createElement("canvas");
      off.width = tw;
      off.height = th;
      const octx = off.getContext("2d");
      octx.fillStyle = "#ffffff";
      octx.fillRect(0,0,tw,th);
      octx.drawImage(canvas, 0, 0, tw, th);

      return off.toDataURL("image/png");
    }

    // ========= è§¦æ‘¸ç»˜ç”»ï¼ˆPointer + Touch å…œåº•ï¼‰ =========
    function setupPointer(){
      const start = (clientX, clientY) => {
        SFX.resume();
        ensureCanvasReady(); // é˜²æ­¢æŸäº›æœºå‹åˆ‡å±åç¬¬ä¸€æ¬¡è§¦æ‘¸è¿˜æ²¡ resize
        draw.isDown = true;
        pushUndo();
        draw.last = getLocalPointLike(clientX, clientY);
        SFX.scribble();
      };

      const move = (clientX, clientY) => {
        if(!draw.isDown) return;
        const p = getLocalPointLike(clientX, clientY);
        drawSegment(draw.last, p);
        draw.last = p;

        const now = Date.now();
        if(now - draw.lastScribbleAt > 55){
          draw.lastScribbleAt = now;
          SFX.scribble();
        }
      };

      const end = () => {
        draw.isDown = false;
        draw.last = null;
      };

      if (window.PointerEvent) {
        canvas.addEventListener("pointerdown", (e)=>{
          e.preventDefault();
          canvas.setPointerCapture(e.pointerId);
          start(e.clientX, e.clientY);
        }, {passive:false});

        canvas.addEventListener("pointermove", (e)=>{
          e.preventDefault();
          move(e.clientX, e.clientY);
        }, {passive:false});

        canvas.addEventListener("pointerup", (e)=>{ e.preventDefault(); end(); }, {passive:false});
        canvas.addEventListener("pointercancel", (e)=>{ e.preventDefault(); end(); }, {passive:false});
      } else {
        canvas.addEventListener("touchstart", (e)=>{
          e.preventDefault();
          const t = e.touches[0];
          if(!t) return;
          start(t.clientX, t.clientY);
        }, {passive:false});

        canvas.addEventListener("touchmove", (e)=>{
          e.preventDefault();
          const t = e.touches[0];
          if(!t) return;
          move(t.clientX, t.clientY);
        }, {passive:false});

        canvas.addEventListener("touchend", (e)=>{ e.preventDefault(); end(); }, {passive:false});
        canvas.addEventListener("touchcancel", (e)=>{ e.preventDefault(); end(); }, {passive:false});
      }
    }

    // ========= è·³è¿‡/è‡ªåˆ¤ =========
    function skipOrSelfJudge(){
      stopTimer();
      SFX.stopTicking();

      const ok = confirm("ä½ è¦è‡ªåˆ¤å—ï¼Ÿ\n\nã€ç¡®å®šã€‘= æˆ‘ç”»å¯¹äº†ï¼ˆä½åˆ†é€šè¿‡ï¼‰\nã€å–æ¶ˆã€‘= è·³è¿‡ï¼ˆæœ¬å›åˆ 0 åˆ†ï¼‰");
      if(ok){
        const gained = 40 + Math.max(0, state.timerLeft);
        state.score += gained;
        state.streak += 1;
        state.bestStreak = Math.max(state.bestStreak, state.streak);

        state.roundLog.push({
          word: state.current.word,
          ok: true,
          points: gained,
          guesses: state.guessCount,
          timeLeft: state.timerLeft,
          note: "è‡ªåˆ¤é€šè¿‡ï¼ˆä½åˆ†ï¼‰"
        });

        aiGuessEl.textContent = "ğŸ“ è‡ªåˆ¤é€šè¿‡";
        aiSubEl.textContent = `ä½ é€‰æ‹©äº†è‡ªåˆ¤é€šè¿‡ï¼š+${gained} åˆ†ï¼ˆä½åˆ†æ¨¡å¼ï¼‰ã€‚`;
        aiConfidenceTag.textContent = "ğŸ¯ ç½®ä¿¡åº¦ï¼šâ€” Â· ğŸ“ è‡ªåˆ¤";
        aiFunnyTag.textContent = "ğŸ§  æç¬‘è¯¯åˆ¤ï¼šâ€”";
        SFX.correct();
      }else{
        state.streak = 0;
        state.roundLog.push({
          word: state.current.word,
          ok: false,
          points: 0,
          guesses: state.guessCount,
          timeLeft: state.timerLeft,
          note: "è·³è¿‡"
        });

        aiGuessEl.textContent = "â­ï¸ å·²è·³è¿‡";
        aiSubEl.textContent = `ç­”æ¡ˆæ˜¯ã€Œ${state.current.word}ã€ã€‚ä¸‹ä¸€é¢˜ç»§ç»­ï¼`;
        aiConfidenceTag.textContent = "ğŸ¯ ç½®ä¿¡åº¦ï¼šâ€”";
        aiFunnyTag.textContent = `ğŸ§  æç¬‘è¯¯åˆ¤ï¼š${pick(FUNNY_WRONG)}`;
        SFX.wrong();
      }

      updateTopChips();
      btnGuess.disabled = true;
      btnNextRound.disabled = false;
    }

    // ========= å·¥å…· =========
    function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
    function escapeHtml(s){
      return String(s||"")
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&#039;");
    }

    // ========= äº‹ä»¶ =========
    btnStartGame.addEventListener("click", ()=>{
      SFX.resume();
      const key = (apiKeyInput.value||"").trim();
      if(key) localStorage.setItem(LS.key, key);
      startGame();
    });

    btnToggleSound.addEventListener("click", ()=>{
      const v = !SFX.isEnabled();
      SFX.setEnabled(v);
      localStorage.setItem(LS.sound, v ? "1" : "0");
      btnToggleSound.textContent = v ? "ğŸ”Š éŸ³æ•ˆï¼šå¼€" : "ğŸ”‡ éŸ³æ•ˆï¼šå…³";
      if(v) SFX.resume();
    });

    btnClearSavedKey.addEventListener("click", ()=>{
      localStorage.removeItem(LS.key);
      apiKeyInput.value = "";
      alert("å·²æ¸…é™¤æœ¬åœ°ä¿å­˜çš„ API Keyã€‚");
    });

    btnPen.addEventListener("click", ()=>{
      draw.mode = "pen";
      btnPen.classList.add("primary");
      btnEraser.classList.remove("primary");
    });

    btnEraser.addEventListener("click", ()=>{
      draw.mode = "eraser";
      btnEraser.classList.add("primary");
      btnPen.classList.remove("primary");
    });

    brushSize.addEventListener("input", ()=>{
      draw.size = parseInt(brushSize.value,10);
      brushLabel.textContent = draw.size;
    });

    btnUndo.addEventListener("click", ()=>{ SFX.resume(); undo(); });
    btnClear.addEventListener("click", ()=>{
      SFX.resume();
      if(confirm("ç¡®å®šæ¸…ç©ºç”»å¸ƒå—ï¼Ÿ")){
        clearCanvas(true);
        pushUndo();
        SFX.wrong();
      }
    });

    btnHint.addEventListener("click", ()=>{ SFX.resume(); useHint(); });
    btnGuess.addEventListener("click", aiGuess);
    btnSkip.addEventListener("click", ()=>{ SFX.resume(); skipOrSelfJudge(); });
    btnNextRound.addEventListener("click", ()=>{ SFX.resume(); nextRound(); });

    btnRestart.addEventListener("click", ()=>{ SFX.resume(); startGame(); });
    btnBackToStart.addEventListener("click", ()=>{
      SFX.resume();
      setScreen("start");
      updateTopChips();
    });

    // ========= åˆå§‹åŒ– =========
    function init(){
      const sound = localStorage.getItem(LS.sound);
      if(sound === "0"){
        SFX.setEnabled(false);
        btnToggleSound.textContent = "ğŸ”‡ éŸ³æ•ˆï¼šå…³";
      }else{
        SFX.setEnabled(true);
        btnToggleSound.textContent = "ğŸ”Š éŸ³æ•ˆï¼šå¼€";
      }

      const savedKey = localStorage.getItem(LS.key) || "";
      if(savedKey) apiKeyInput.value = savedKey;

      // å…ˆåœ¨å°é¢é¡µåˆå§‹åŒ–ä¸€æ¬¡ï¼ˆå¯é€‰ï¼‰ï¼ŒçœŸæ­£æœ‰æ•ˆçš„ resize ä¼šåœ¨è¿›å…¥ play æ—¶åš
      requestAnimationFrame(()=>{
        ensureCanvasReady(true);
        clearCanvas(true);
        pushUndo();
      });

      // æ—‹è½¬/resize
      window.addEventListener("resize", ()=>{
        clearTimeout(init._rt);
        init._rt = setTimeout(()=>{
          if(state.phase === "play"){
            ensureCanvasReady(true);
          }
        }, 120);
      });

      // ç›‘å¬ç”»å¸ƒå®¹å™¨å°ºå¯¸å˜åŒ–ï¼ˆæ›´ç¨³ï¼šå°¤å…¶æ˜¯åœ°å€æ æ”¶èµ·/å¼¹å‡ºï¼‰
      if("ResizeObserver" in window){
        const ro = new ResizeObserver(()=>{
          if(state.phase === "play"){
            ensureCanvasReady(true);
          }
        });
        ro.observe(canvasFrame);
      }

      setupPointer();

      btnPen.classList.add("primary");
      btnEraser.classList.remove("primary");
      draw.size = parseInt(brushSize.value,10);
      brushLabel.textContent = draw.size;

      updateTopChips();
    }
    init();

    // iOSï¼šé¦–æ¬¡è§¦æ‘¸å”¤é†’éŸ³é¢‘
    window.addEventListener("pointerdown", ()=>SFX.resume(), { once:false });
  </script>
</body>
</html>
